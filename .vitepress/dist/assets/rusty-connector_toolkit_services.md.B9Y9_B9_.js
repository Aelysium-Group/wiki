import{_ as i,c as e,a1 as a,o as t}from"./chunks/framework.C7abYapc.js";const d=JSON.parse('{"title":"ðŸ›œ Services","description":"","frontmatter":{"title":"ðŸ›œ Services","sidebar_position":2},"headers":[],"relativePath":"rusty-connector/toolkit/services.md","filePath":"rusty-connector/toolkit/services.md"}'),n={name:"rusty-connector/toolkit/services.md"};function l(o,s,c,h,p,r){return t(),e("div",null,s[0]||(s[0]=[a(`<p>Services are the framework that RustyConnector is based off of. Every process in RustyConnector is a Service. Sometimes Services might contain sub-services.</p><p>Let&#39;s look at the Service interface quickly.</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">public</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> interface</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Service</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    /**</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * Kill the service.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     * Every service is solely responsible for killing its own processes.</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">     */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    void</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> kill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>Services all have a single common denominator, they can be stopped via the <code>.kill()</code> method. When <code>.kill()</code> is called on a Service, it is expected that not only the Service itself stops, but also all sub-processes of that service. With this setup, we can simply call <code>.kill()</code> on the main plugin Service and the entire plugin will shut down!</p><h2 id="accessing-rustyconnector-services" tabindex="-1">Accessing RustyConnector Services <a class="header-anchor" href="#accessing-rustyconnector-services" aria-label="Permalink to &quot;Accessing RustyConnector Services&quot;">â€‹</a></h2><p>The root RustyConnector Service is the Flame, which you access via Tinder. From there you can access the main Services associated with the Flame.</p><div class="language-java vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">java</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">VelocityTinder tinder </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> RustyConnector.Toolkit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">orElseThrow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tinder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onStart</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(flame </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    flame.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">services</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tinder.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onStop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>Notice how we have to access Flame from within an <code>.onStart()</code> method? Flame itself is a Service, which means that it isn&#39;t guaranteed to be active. When we call <code>.onStart()</code> we know that we&#39;ll be able to access Flame once it&#39;s active. Alternatively <code>.onStop()</code> will run when <code>.kill()</code> is used on Flame.</p><div class="info custom-block"><p class="custom-block-title">INFO</p><p>While building your RustyConnector Module; it&#39;s a good practice to write as much logic outside of <code>.onStart()</code> as you possibly can.</p><p>You should only need <code>.onStart()</code> for RustyConnector specific functions such as registering Event Listeners.</p></div>`,9)]))}const E=i(n,[["render",l]]);export{d as __pageData,E as default};
